#ifndef SEMAPHORE_H_
#define SEMAPHORE_H_

#include <os_types.h>
#include <arch\syn\spinlock.h>
/**
 * Семафор по реализации очень похож на мьютекс.
 * Также предусматривается возможность выполнения части кода на уровне пользователя,
 * обеспечивая при этом функционал быстрых семафоров.
 * Аналогично мьютексам различаем 2 типа семафоров:
 * 1) Семафор, размещенный в памяти ядра ОС.
 * Работа с ним возможна только внутри ядра. Если он создан процессом,
 * это значит что процесс может с ним работать только через системные вызовы.
 * 2) Семафор, счетчик которого и некоторые др. поля размещены в памяти процесса.
 * Благодаря размещению счетчика в памяти процесса потоки могут предпринимать попытки захвата
 * и освобождать семафор без выполнения системных вызовов. Только в случае неудачного захвата
 * выполняется системный вызов и ядро блокирует поток до успешного захвата.
 * В то же время семафор второго типа можно применять и для межпроцессной синхронизации,
 * если разрешить доступ к памяти другим процессам. Для этого необходимо выделять
 * отдельную страницу(ы) памяти через системный вызов. Сам процесс передачи выполняется
 * передачей системного сообщения целевым процессам в доступные каналы сообщений, что не всегда
 * возможно и приемлемо.
 *
 * Системный вызов выполняется одинаково для 2-х видов семафоров, разница только в области применения
 * из-за местонахождения рабочих данных.
 */

typedef struct {
//    enum syn_type   type;
    int             limit;          // стартовое значение
    atomic_t        *cnt;           // основной рабочий счетчик
    spinlock_t      wait_lock;      // спинлок очереди ожидающих потоков
    struct thread   *wait_first;
    struct thread   *wait_last;
    atomic_t        __cnt;          // для SEMAPHORE_TYPE_PSHARED
    char            *name;          // имя
} semaphore_t;

int sem_init(semaphore_t *sem, syn_t *s);
int sem_lock(semaphore_t *sem, struct thread *thr, uint64_t ns);
int sem_wait_cancel(semaphore_t *sem, struct thread *thr);
int sem_trylock(semaphore_t *sem, struct thread *thr);
int sem_unlock(semaphore_t *sem, struct thread *thr);

#endif /* SEMAPHORE_H_ */
