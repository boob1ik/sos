#ifndef NAMESPACE_H_
#define NAMESPACE_H_

typedef struct namespace_node {
    int value;                  //!<    Информация об объекте: числовое значение
    void *ref;                  //!<    Информация об объекте: ссылка
} namespace_node_t;

#define NAMESPACE_DEFAULT_SEPARATOR         '/'
#define NAMESPACE_DEFAULT_ALT_SEPARATOR     '\\'

typedef void * namespace_t;

/**
 * Инициализация модуля
 * @return
 */
void ns_init (namespace_t *ns);
void ns_init_custom (namespace_t *ns, char separator, char alt_separator);

/**
 * @return символ-разделитель '/'
 */
char ns_get_separator (namespace_t *ns);

/**
 * @return символ-разделитель '\'
 */
char ns_get_alt_separator (namespace_t *ns);

/**
 *  Функция создает в корневом пространстве имен узел(структуру) для хранения информации об объекте.
 *  Узлу соответствует заданный путь, начиная с корня пространства. Первый символ-разделитель может отсутствовать.
 *  При создании автоматически создается поддерево несуществующих узлов-папок, которые соответствуют именам между
 *  символами-разделителями, или используются существующие узлы-папки.
 *
 *  После успешного создания узел является заблокированным и прерывания запрещены. Необходимо внести данные
 *  об объекте, например по ns_node_set_ref и/или ns_node_set_value, и как можно скорее вызвать функцию
 *  ns_unlock, которая разблокирует объект и восстановит исходное состояние системного флага прерываний
 *  до вызова ns_create.
 *
 *  Поля объекта хранения ссылки можно изменять. Но обращаться к ним можно только учитывая жизненный цикл
 *  объекта хранения, который заканчивается по ns_delete. Необходимо выполнять блокировку объекта
 *  по ns_search_and_lock для обеспечения безопасного доступа к данным.
 *
 *  Особенности реализации корневого пространства имен.
 *  1) Допускаются вложенные узлы(объекты) ядра.
 *  2) В существующих узлах нельзя создавать новые узлы, которым соответствует такой же путь от корня.
 *  3) При удалении соответствующий узел становится узлом-папкой, если есть другие объекты ниже по дереву.
 *     Исключение - п. 4). Такой узел будет пропускаться при поиске первого встречного объекта.
 *  4) При удалении узла можно указать, чтобы он был освобожден из памяти только после освобождения из памяти всего
 *      поддерева ниже него. Функция поиска первого встречного объекта при этом будет возвращать ошибку на данном узле.
 *
 *
 * @param  pathname
 * @param  node               ссылка на объект хранения
 * @param  type               тип объекта, применяется для идентификации данных об объекте
 * @return  OK                      - через указатель node возвращена ссылка на созданный объект хранения
 *          ERR_ILLEGAL_ARGS        - пустые значения pathname и/или node
 *          ERR_PATHNAME_TOO_LONG   - длина строки превышает предел PATHNAME_MAX_LENGTH
 *          ERR_ACCESS_DENIED       - невозможно создать объект по такому пути (занят)
 */
int ns_node_create_and_lock (namespace_t *ns, char *pathname, struct namespace_node **node, int type);

/**
 * Поиск и блокировка объекта хранения в корневом пространстве имен по пути для дальнейшей безопасной работы
 * с запрещенными прерываниями. Разблокировка должна быть выполнена как можно скорее по ns_unlock.
 * Пространство ns не блокировано после выполнения функции, то есть в SMP системе на другом ядре может быть выполнен
 * захват и работа с другим объектом ns.
 *
 * Вызов применяется в 2-х версиях поиска:
 *
 * 1) Поиск объекта по точному совпадению полного пути pathname, начиная с корня пространства.
 *    В середине пути могут находиться любые объекты и папки, для них никаких проверок и правил не применяется.
 *
 *      (suffix == NULL) || (*suffix == NULL)
 *
 * 2) Сначала выполняется позиционирование на начало суффикса, начиная с корня пространства по pathname.
 *  Затем выполняется поиск ниже по суффиксу первого встречного объекта. Узлы-папки пропускаются.
 *  На удаленном но не освобожденном из памяти объекте(при наличии поддерева) будет возвращена ошибка,
 *  но указатели suffix и found будут соответствовать этому объекту. При необходимости можно посмотреть
 *  значения полей узла (за исключением типа) и продолжить поиск ниже по дереву.
 *
 *      (suffix != NULL) && (*suffix != NULL)
 *
 * @param           pathname        - полный путь
 * @param[in/out]   suffix          - указатель на ссылку суффикса пути поиска, Внимание! только на память, где pathname
 * @param[out]      found           - указатель на ссылку объекта
 *
 * @return  OK                      - объект найден и заблокирован для работы с ним
 *          ERR_ILLEGAL_ARGS        - не допустимые аргументы: (pathname == NULL) || (found == NULL) ||
 *                                      (*suffix) > (pathname + PATHNAME_MAX_LENGTH - 1)
 *          ERR_PATHNAME_TOO_LONG   - длина строки превышает предел PATHNAME_MAX_LENGTH
 *          ERR                     - по такому пути не найден объект
 *          ERR_ACCESS_DENIED       - недопустимый путь или для случая 2) встретился удаленный узел с поддеревом
 */
int ns_node_search_and_lock (namespace_t *ns, char *pathname, char **suffix, struct namespace_node **found);

/**
 * Разблокировка объекта хранения в корневом пространстве имен
 * с восстановлением флага прерываний до вызова search_and_lock или create_and_lock
 * @param node
 * @return
 */
int ns_node_unlock (namespace_t *ns, struct namespace_node *node);

/**
 * Функция удаляет из корневого пространства имен объект хранения ссылки по ссылке.
 * Внимание! Правило. Удаление может выполнять только модуль(процесс), который создал узел
 * и управляет его существованием. Должно гарантироваться в системе что только одно ядро в SMP режиме или
 * один процесс имеет право хранить ссылку {struct namespace_node *} постоянно. Остальные (читатели) имеют право
 * пользоваться указанной ссылкой только при ее получении по ns_lock и до последующего вызова ns_unlock.
 * После этого ссылка является устаревшей и может не отражать текущее наличие указанного объекта в пространстве.

 * Узел будет удален только если свободен, то есть не заблокирован.
 * Выполняется бесконечный цикл активного энергоэффективного ожидания в случае, если узел занят.
 * @param node                  ссылка, полученная по ns_create
 * @param retain_while_subtree  0 - если есть поддерево, то узел перейдет в статус узла-папки, которая будет
 *                                  пропускаться при поиске первого встречного объекта;
 *                              1 - автоматически освободить из памяти только после удаления всего поддерева,
 *                                  то есть узел не становится узлом-папкой после удаления, а
 *                                  поиск первого встречного объекта по пути остановится на этом узле с ошибкой
 *
 * @return  ERR_ILLEGAL_ARGS если ((node == null) || (node == &root) ), иначе OK после выполнения
 */
int ns_node_delete (namespace_t *ns, struct namespace_node *node, int retain_while_subtree);

/**
 * Версия функции удаления для блокированного узла.
 * Важно!!! Имеет право выполнять только код, захвативший узел после поиска или создания.
 * Проверок внутри на этот счет не выполняется.
 * @param node                  ссылка, полученная по ns_create
 * @param retain_while_subtree  аналогично обычной функции удаления
 * @return
 */
int ns_node_delete_locked (namespace_t *ns, struct namespace_node *node, int retain_while_subtree);

/**
 * @param node
 * @return тип объекта, который был задан при создании
 */
int ns_node_get_objtype(struct namespace_node *node);

static inline int ns_node_get_value(struct namespace_node *node)
{
    return node->value;
}

static inline void ns_node_set_value(struct namespace_node *node, int value)
{
    node->value = value;
}

static inline void *ns_node_get_ref(struct namespace_node *node)
{
    return node->ref;
}

static inline void ns_node_set_ref(struct namespace_node *node, void *ref)
{
    node->ref = ref;
}

#endif /* NAMESPACE_H_ */
