#ifndef RESMGR_H_
#define RESMGR_H_
#include <os_types.h>
#include <syn/ksyn.h>
#include <rbtree.h>

/**
 * Менеджер ресурсов(ссылок на объекты и доп. информации по ним) или объектов ядра,
 * обеспечивает управление хранилищами (контейнерами) объектов с синхронизированными методами доступа.
 * Для хранения объектов по ID номерам:
 *   мьютексы, семафоры, барьеры, каналы сообщений и т.д.
 * Можно применять и вне ядра, если поменять объект синхронизации на мьютекс.
 * ОС может применять разные контейнеры для разных типов объектов
 * или обобщенный контейнер с одним пространством номеров.
 *
 * Объекты помещаются копированием в динамическую память хранилища с выравниванием на 8 байт.
 * Из хранилища объекты доступны по ссылке на копию данных.
 * Для экономии памяти размер данных копии в явном виде не хранится.
 * Размер объектов может быть произвольно разным, идентификация типов объектов и размера является
 * задачей более высокого уровня и обычно сводится к наличию поля типа и поля размера где нужно.
 *
 * Основная идея реализации нашего универсального контейнера - максимальная производительность вместе с
 * универсальностью. Для этого предусматриваем объединение выделяемой памяти на каждый узел
 * к-ч. дерева хранилища с копией данных объекта.
 *
 * Полная инкапсуляция здесь не нужна, структура контейнера открыта.
 * Инициализация деревьев и управление ими ведется полностью менеджером.
 * Разрешенные пределы номеров - положительные от 1 до INT_MAX.
 * Поддерживаются 2 диапазона номеров: статический для прямого захвата и динамический
 * для захвата любого свободного номера.
 * Диапазоны статического и динамического выделения не должны перекрываться.
 * Если это не так при инициализации, то будет создан контейнер с нулевым объемом и возвращается ошибка.
 *
 * TODO Делать или нет?
 * Динамические номера вначале захватываются последовательно по убыванию номеров до
 * исчерпания начального диапазона. Освобождаемые динамические номера добавляются в не активное
 * дерево диапазонов. После исчерпания свободных номеров активного дерева происходит смена
 * активного дерева. Такой алгоритм позволяет обеспечить отсутствие быстрых перезахватов номеров,
 * то есть обечпечивает уникальность номеров ресурсов на более длительном временном интервале.
 * Это свойство может быть полезно для отладки ПО при логировании каких-либо процессов для идентификации
 * ресурсов или для других целей оценки функционирования ПО. Так, например, может выполняться
 * оценка корректности запуска операционной системы и группы процессов путем сравнения
 * полученного номера ресурса с каким-то опытным предыдущим значением, а также общий объем
 * созданных динамических ресурсов за начальный этап функционирования системы.
 */
struct res_info {
    void *res;
    size_t res_len;
};

struct res_container {
    kobject_lock_t lock;
    int id;      // первый номер и количество номеров для статического захвата
    int id_cnt;
    int dynid;   // первый номер и количество номеров для динамического выделения
    int dynid_cnt;
    struct rb_tree objects;
    struct rb_tree free_dynids;
//    struct rb_tree free_dynids[2]; // TODO
//    int active_free_tree;
};

#define RES_ID_MIN      (1)

/**
 * Внимание! Методы без проверки аргумента *container и *nfo для ускорения обработки
 */

/**
 * Инициализация контейнера с двумя диапазонами номеров ресурсов: статическим и динамическим.
 * При добавлении ресурса в контейнер необходимо либо указать заданный статический номер для захвата, либо
 * запросить сгенерированный номер в динамическом диапазоне.
 * @param container
 * @param min           - начальное значение диапазона статических номеров
 * @param max           - последнее значение диапазона статических номеров
 * @param min_dynamic   - начальное значение диапазона динамических номеров
 * @param max_dynamic   - последнее значение диапазона динамических номеров
 * @return OK - инициализация выполнена
 *         ERR - ошибка инициализации. Неверно указаны значения диапазонов, они не должны перекрываться.
 */
int res_container_init(struct res_container *container, int min, int max, int min_dynamic, int max_dynamic);

/**
 * Инициализация полностью статического контейнера. См. выше.
 * @param container
 * @param min
 * @param max
 * @return
 */
int res_container_init_static(struct res_container *container, int min, int max);

/**
 * Инициализация полностью динамического контейнера. См. выше.
 * @param container
 * @param min_dynamic
 * @param max_dynamic
 * @return
 */
int res_container_init_dynamic(struct res_container *container, int min_dynamic, int max_dynamic);

/**
 * Инициализация по умолчанию, - половина младших номеров для статического захвата,
 * половина старших - для динамического размещения
 */
int res_container_init_default(struct res_container *container);

/**
 * Удаление всех ресурсов из контейнера. Выполняется вызов callback-функции res_free для освобождения
 * памяти внешними средствами, если это необходимо. После этого освобождается память,
 * занимаемая объектом в самом контейнере. Эта версия универсальная, может применяться как для очистки памяти
 * объектов размещенных по res_put_ref(в этом случае по указателю res будет находиться ссылка на объект),
 * так и для очистки объектов, размещенных по res_put(в этом случае по res будут находиться данные объекта
 * в памяти контейнера).
 * ВНИМАНИЕ! Не допускается рекурсия вызовов функций этого модуля из callback-функции.
 * @param container
 * @param res_free callback-функция для очистки дополнительной памяти, занимаемой объектами за пределами контейнера
 *                  id - номер ресурса, res - ссылка на объект в контейнере
 * @return число удаленных ресурсов(объектов) из контейнера
 */
int res_container_free(struct res_container *container, void (*res_free) (int id, void *res));

/**
 * Удаление всех ресурсов из контейнера.  Выполняется вызов callback-функции res_free для освобождения
 * памяти внешними средствами. После этого освобождается память, занимаемая ресурсом в самом контейнере.
 * Эта версия предназначена для очистки контейнера, который применялся только для хранения ссылок на объекты
 * по res_put_ref.
 * ВНИМАНИЕ! Не допускается рекурсия вызовов функций этого модуля из callback-функции.
 * @param container
 * @param res_free res_free callback-функция для очистки памяти занимаемой объектами за пределами контейнера,
 *                 то есть по ссылке obj может быть необходимо вызвать например kfree(obj);
 * @return число удаленных ресурсов из контейнера
 */
int res_container_byref_free(struct res_container *container, void (*ref_free) (int id, void *obj));

/**
 * В контейнер (динамическую память) под заданным или любым свободным номером
 * будет помещена копия данных из nfo.res размером nfo.res_len.
 * При этом данные копии будут выравнены всегда на 8 байт для корректного обращения к ним
 * после обратного получения ссылки по res_get.
 * После выполнения nfo.res будет являться ссылкой на копию.
 *
 * Пример использования.
 * Для применения хранилища только для ссылок на объекты одного типа, которые
 * размещаются в динамической памяти внешним кодом самостоятельно, в памяти по указателю nfo.res
 * необходимо разместить значение ссылки на исходный объект и установить nfo.res_len = 0. В хранилище будет помещена
 * ссылка и ее нужно не забыть удалить по res_remove при удалении исходного объекта и наоборот,
 * не забыть о существовании отвязанного объекта при удалении из хранилища ссылки.
 *
 * \param id - если = 0 номер берется из динамического диапазона, иначе должен быть указан номер из статического
 * \param nfo - информация о ресурсе, ее копия будет помещена в контейнер
 * \return \ERR, \ERR_BUSY или номер ресурса при успешном выполнении
 */
int res_put(struct res_container *container, int id, struct res_info *nfo);

/**
 * В контейнер под заданным или любым свободным номером будет помещена ссылка на объект.
 *
 * \param id - если = 0 номер берется из динамического диапазона, иначе должен быть указан номер из статического
 * \param obj - ссылка на объект является ресурсом, помещаемым в контейнер, значение NULL не допустимо (будет \ERR)
 * \return \ERR, \ERR_BUSY или номер ресурса при успешном выполнении
 */
int res_put_ref(struct res_container *container, int id, void *obj);

/**
 * По заданному номеру производится поиск объекта в контейнере и возвращается ссылка
 * на него через nfo.res, значение nfo.res_len в текущей реализации функции не определено.
 * При этом объект сохраняется в контейнере до его удаления по res_remove.
 *
 * \param id - номер ресурса из статического или динамического диапазона
 * \param nfo - информация о ресурсе будет помещена сюда, если ресурс будет найден
 * \return \ERR или \OK с инициализацией nfo
 */
int res_get (struct res_container *container, int id, struct res_info *nfo);

/**
 * По заданному номеру производится поиск и возврщение ссылки на объект
 * \return ссылка на объект, если найден соответствующий ресурс по заданному номеру, иначе NULL
 */
void *res_get_ref(struct res_container *container, int id);

/**
 * Удаление объекта.
 * Чтобы одной транзакцией получить ссылку на объект,
 * проанализировать состояние объекта и удалить его при необходимости,
 * необходимо применять внешний код блокировки ядра ОС по container.lock
 * kobject_lock до res_get и kobject_unlock после res_remove
 */
int res_remove (struct res_container *container, int id);

#endif /* RESMGR_H_ */
