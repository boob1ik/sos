#ifndef OS_H
#define OS_H

#ifdef __cplusplus
extern "C" {
#endif

#include <os_types.h>

/** \page intro Введение
    Документация по системным вызовам.
    \version   0.1a
    \date      2013
    \author    noname
    \copyright RCZI FORT
*/

/** \defgroup API Системные вызовы */
/** \name Управление процессами */
/**@{*/

    /** \defgroup proc Процессы
        \ingroup API */
    /**@{*/

    /** \brief Инициализация и запуск нового процесса

        Номер вызова: \b SYSCALL_PROC_CREATE

        \c ПРОЦЕСС

        Процесс оформляется обычно в виде единого бинарного образа, который состоит из заголовка \struct proc_header
        и сегментов памяти \struct proc_seg исполняемого кода и данных.\n
        Заголовок определяет необязательное имя процесса с относительным путем внутри /proc/ в корневом пространстве
        имен, точку входа и начальный размер стека стартового потока, таблицу сегментов памяти с атрибутами
        их инициализации. В то же время, заголовок может не являться непосредственно частью бинарного образа процесса,
        а также сегменты памяти могут быть разбросаны и не составлять единого бинарного образа для процесса с сегментами
        по абсолютным адресам физической памяти.\n
        Процесс может быть подготовлен как позиционно независимый и собран в виде единого образа с нулевого начального
        адреса. В этом случае адрес каждой секции является смещением относительно начала размещения бинарного образа в
        памяти.\n
        Запуск нескольких экземпляров процесса в системе возможен только для двух типов процессов:
        \n- для позиционно зависимых образов с сегментами, помеченными флагом mem_attributes_t.multi_alloс, и без
        сегментов для чтения и записи;
        \n- для позиционно независимых образов, которые при наличии сегментов для чтения и записи должны быть
        скопированы в новую область памяти перед запуском нового экземпляра процесса, иначе копирование образа можно не
        выполнять в том числе при наличии секций с флагом разрешения множественного выделения памяти разным процессам.
        \n
        Если сегменты памяти нового процесса в момент системного вызова принадлежат родительскому процессу и не помечены
        для множественного доступа флагом mem_attributes_t.multi_alloc, то они будут переданы во владение новому
        процессу и родительский потеряет к ним прямой доступ.
        \n\n
        Запуск нового процесса не возможен, если образ содержит сегменты для чтения и записи(в общем случае сегменты
        глобальных переменных), и в системе уже существует другой процесс с такой же рабочей областью памяти.
        Это связано с ограничениями концепции ОС прямой модели памяти без виртуализации адресов. Также размеры стеков
        имеют важное значение, так как в этой концепции не предусмотрен динамический рост стеков.
        \n\n
        Рабочие параметры вызова передаются и принимаются через структуру \struct proc_attr. По требованию может быть
        установлен заданный номер нового процесса, его приоритет, входные данные. Будет создана копия входных данных
        и отдана во владение новому процессу. При невозможности установки заданных параметров процесс не будет создан и
        будет возвращена ошибка ERR_ILLEGAL_ARGS.

        \warning Процесс создается с параметрами безопасности, если в системе существует зарегистрированный в ядре
        менеджер безопасности МБ.\n
        Если МБ отсутствует, система работает как равнопользовательская и любые процессы могут порождать другие процессы
        и взаимодействовать друг с другом через системные вызовы без ограничений.

        \note Дополнительные инструменты загрузки программных модулей и вызова методов библиотек
        не входят в состав ядра ЗОС.

        \param hdr   Заголовок процесса
        \param attrs Входные и выходные параметры процесса

        \return Идентификатор процесса (PID > 0) или код ошибки (<0). PID является корректным пока не получен сигнал
                о завершении запущенного процесса и только при зарегистрированном обработчике сигналов на момент вызова
        \retval ERR_ILLEGAL_ARGS   Неверные входные аргументы или параметры
        \retval ERR_PROC_LIMIT     Превышен лимит процессов в системе
        \retval ERR_THREAD_LIMIT   Превышен лимит потоков в системе
        \retval ERR_NO_MEM         Ошибки памяти
    */
    __syscall int os_proc_create (const struct proc_header *hdr, struct proc_attr *attrs);


    /** \brief Уничтожение процесса

        Номер вызова: \b SYSCALL_PROC_KILL

        Принудительное уничтожения процесса с освобождением всех ресурсов процесса и завершением его потоков.\n
        Завершение потоков аналогично вызову \c thread_kill.

        \param pid  Идентификатор процесса

        \return Ошибки выполнения запроса
        \retval ERR_PROC_NON_EXISTENT     Указанного процесса не существует
    */
    __syscall int os_proc_kill (int pid);


    /** \brief Получение информации о процессе

        Номер вызова: \b SYSCALL_PROC_INFO

        Заполнение ядром структуры proc_info, которая содержит всю информацию о данном процессе.

        \param[in]  pid  Идентификатор процесса
        \param[out] info Структура информации

        \return Ошибки выполнения
        \retval ERR_PROC_NON_EXISTENT     Указанного процесса не существует
    */
    __syscall int os_proc_info (int pid, struct proc_info *info);

    /**@}*/

/**@}*/


/** \name Вызовы работы с потоками */
/**@{*/

    /** \defgroup thread Потоки
        \ingroup API */
    /**@{*/

    /** \brief Создание потока

        Номер вызова: \b SYSCALL_THREAD_CREATE

        Создание потока в контексте текущего процесса.\n

        \param attrs          Параметры потока:
               attrs.entry          Стартовая функция потока
               attrs.arg            Аргумент стартовой функции
               attrs.tid            Установленный номер потока, можно использовать только в текущем процессе
               attrs.ts             Размер кванта (в тиках)
               attrs.stack_size     Размер стека потока
               attrs.type           Тип потока
                                    THREAD_TYPE_JOINABLE
                                                       - поток не удаляется из памяти при его завершении, таким образом
                                                         гарантируется корректность идентификатора tid потока до
                                                         выполнения os_thread_join или os_thread_kill
                                    THREAD_TYPE_DETACHED
                                                       - поток с автоматическим удалением из памяти при завершении,
                                                         после создания и запуска такого потока по os_thread_run
                                                         полученный идентификатор tid использовать в других системных
                                                         вызовах не корректно, так как при завершении потока tid может
                                                         быть занят любым новым потоком в системе. Исключение - если
                                                         поток был создан как обработчик прерывания, то он не
                                                         удаляется из памяти до его освобождения от вектора прерывания
                                                         по os_irq_release, os_thread_run в этом случае не применяется.
                                    THREAD_TYPE_IRQ_HANDLER
                                                       - поток-обработчик прерывания, может применяться только для
                                                         регистрации обработки заданного вектора прерывания основного
                                                         контроллера прерываний в системе по os_irq_hook
               attrs.flags          Флаговые параметры

        \return Идентификатор созданного потока tid или код ошибки
        \retval ERR_THREAD_LIMIT             Превышен лимит процессов в системе
    */
    __syscall int os_thread_create (struct thread_attr *attrs);

    /** \brief Завершение потока

        Номер вызова: \b SYSCALL_THREAD_EXIT

        Завершение выполняющегося потока.\n
        Вызывается самим потоком. Если вызов в явном виде не выполнен, то возвращается значение стартовой функции,
        которая для этого должна иметь возвращаемый тип int

        \warning Зарегистрированные обработчики прерываний не удаляются и сбрасываются в исходное состояние

        \param result код возврата, который может быть получен при выполнении os_thread_join из другого потока
        \return Управление не возвращается
    */
    __syscall int os_thread_exit (int result);


    /** \brief Удаление потока

        Номер вызова: \b SYSCALL_THREAD_KILL

        Удаление заданного потока текущего процесса из памяти в разных режимах:
        - принудительное прекращение существования любого потока,
        - запрос потоку THREAD_TYPE_JOINABLE на его завершение,
        - перевод потока THREAD_TYPE_JOINABLE в THREAD_TYPE_DETACHED.

            В первом случае флаги не указываются, заданный поток будет сразу удален из системы без вызова
        зарегистрированных им функций очистки и деструкторов. При этом номер tid удаленного потока может быть
        сразу занят другим потоком текущего или любого другого процесса. Все "потерянные" ресурсы, которые были
        запрошены удаленным потоком у ядра и остались неизвестными для других потоков процесса, будут возвращены
        в систему только после завершения всего процесса. Может применяться в исключительных случаях и только для
        удаления одиночных потоков без их перезапуска с возможным циклическим повторением ситуации, так как это
        может привести к пустому расходованию системной памяти.

            Для потоков THREAD_TYPE_JOINABLE существует возможность установить флаг запроса завершения потока, который
        может сканироваться потоком в выбранных точках. Текущая версия ОС поддерживает прерывание потоков только типа
        THREAD_TYPE_JOINABLE и только в точках сканирования, определенных разработчиком прикладного ПО. Такой механизм
        прерывания потоков является основным и рекомендуется к применению там, где это необходимо. Он обеспечивает
        корректное завершение потока с выполнением всех зарегистрированных потоком функций очистки и деструкторов.
        После установки запроса необходимо выполнить ожидание завершения потока по os_thread_join или перевести
        THREAD_TYPE_JOINABLE-поток в тип THREAD_TYPE_DETACHED для корректной очистки системной памяти от потока.

            Если нет необходимости в ожидании завершения потока THREAD_TYPE_JOINABLE по os_thread_join и такой
        вызов не будет выполнен в коде, то необходимо корректно очистить системную память от потока по os_thread_kill
        с флагом THREAD_DETACH. Это позволит создавать и прекращать работу новых потоков в процессе без набегающей
        занятой впустую системной памяти завершенных потоков THREAD_TYPE_JOINABLE.


        \warning Зарегистрированные обработчики прерываний не удаляются

        \param tid      Идентификатор потока
        \param flags    THREAD_CANCEL     - установить флаг запроса завершения потока, только для THREAD_TYPE_JOINABLE
                        THREAD_DETACH     - перевести поток из THREAD_TYPE_JOINABLE в THREAD_TYPE_DETACHED;
                                            поток сразу или позже удалится из памяти автоматически, если завершен
        \return Ошибки выполнения
    */
    __syscall int os_thread_kill (int tid, int flags);

    #define THREAD_CANCEL           1
    #define THREAD_DETACH           2


    /** \brief Ожидание завершения потока

        Номер вызова: \b SYSCALL_THREAD_JOIN

        Блокировка текущего потока до завершения существования (вызов exit или kill) заданного потока.
        Блокироваться можно только на потоки своего процесса, имеющие статус THREAD_JOINABLE

        \param tid  Идентификатор потока

        \return Ошибки выполнения
    */
    __syscall int os_thread_join (int tid);


    /** \brief Передача управления

        Номер вызова: \b SYSCALL_THREAD_YIELD

        Завершение работы потока до истечения кванта времени.
        Блокировки потока не происходит.

        \return Ошибки выполнения
    */
    __syscall int os_thread_yield ();


    /** \brief Наследованная передача управления другому потоку

        Номер вызова: \b SYSCALL_THREAD_YIELD_TO

        Передача остатка кванта времени и приоритета другому потоку.\n

        Реализует возможность объединения нескольких произвольных потоков в связанную последовательность выполнения
        на основе характерстик (кванта, приоритета) базового потока.
        Каждый поток после завершения своей части работы либо делает связанным следующий поток последовательности, либо завершает ее.
        Последовательность реализуется только порядоком вызова yield_to.
        По истечении кванта времени последовательность прерывается.

        ----

        Q-последовательность: логически организованный последовательный порядок вызовов.\n
        Диспетчер начинает или продолжает начатую Q-последовательность переключений между потоками одного или нескольких процессов.
        Одна Q-последовательность переключений выполняется в рамках кванта времени первого потока, инициирующего быстрое взаимодействие.
        Потоки, осуществляющие взаимодействие в одном кванте времени, поднимаются в приоритете до исходного потока,
        который инициировал это взамодействие в текущем кванте времени.
        Q-последовательность завершится автоматически после исчерпания кванта времени. После завершения все потоки кроме исходного, которые участвовали в быстром обмене,
        возвращаются в очередь планирования на исполнение в соответсвии с их приоритетами так, как будто они не
        выполнялись в указанном кванте времени. Исходный поток возвращается в очередь планирования как отработавший полностью свой квант времени.
        Q-последовательность может быть завершена до исчерпания кванта времени последующими системными вызовами (например thread_yield, thread_join) из потоков,
        если не осталось активных потоков Q-последовательности.

        Диспетчер также завершает Q-последовательность, если при очередном вызове yield_to
        остаток кванта времени меньше минимального значения, определяемого производительностью платформы и конфигурацией ЗОС.

        ----

        Фактически вызов реализует сущность nice только более нагло :)
        Поток получивший время хочет выжрать все свое возможное время без остатка, чтоб его никто из его очереди не прервал.
        Да к тому же, если ему требуется что-то от низкоприоритетных потоков - он делает нам тут инверсию и безобразничает.
        Абсолютно не nice тип :)

        Короче это тот кто стоял перед вами в очереди, а когда она пришла - оказалось, что у него куча родственников в других очередях, и он всех их зовет и пропускает :)
        Вы рады? )

        п.с. Но стоит отметить, что покупатель не нарушет правила, потому что в уставе магазина написано, что каждый покупатель должен обслуживаться не более 10 минут.
        А он время не превышает, у него 9 родственников, и каждого обслуживают 1 минуту + 1 минуту на него самого.
        Вы сами согласились на эти правила, когда зашли в магазин.

        ----

        \note Предназначен для реализации быстрых механизмов взаимодействия в системе ))
        \warning Передача возможна только внутри процесса.

        \param tid  Идентификатор потока

        \return Ошибки выполнения
    */
    __syscall int os_thread_yield_to (int tid);


    /** \brief Запуск созданного или остановленного потока

        Номер вызова: \b SYSCALL_THREAD_RUN

        Поток будет помещен в очередь планирования на исполнение.

        \param tid  Идентификатор потока

        \return Ошибки выполнения
    */
    __syscall int os_thread_run (int tid);


    /** \brief  Остановка потока

        Номер вызова: \b SYSCALL_THREAD_STOP

        Поток будет остановлен и изъят из очереди планирования.

        \param tid  Идентификатор потока

        \return Ошибки выполнения
    */
    __syscall int os_thread_stop (int tid);


    /** \brief Пауза

        Номер вызова: \b SYSCALL_THREAD_SLEEP

        Задержка выполнения потока на заданное время в наносекундах.
        Если требуемое время не выходит за рамки текущего кванта времени потока,
        будет выполнено ожидание в пустом цикле по системному времени.
        В противном случае, диспетчер переведет поток в спящий режим на заданное время и
        выполнит переключение контекста на следующий в очереди поток, если он есть.

        \warning Частый вызов бесцельно раходует процессороное время снижая производительность системы!

        \param timeout  время ожидания, нс

        \return Ошибки выполнения
    */
    __syscall int os_thread_sleep (uint64_t timeout);


    /** \brief Установка приоритета потока

        Номер вызова: \b SYSCALL_THREAD_PRIO

        \param tid Идентификатор потока
        \param val Абсолютное значение приоритета

        \return Ошибки выполнения, текущий или установленный приоритет
    */
    __syscall int os_thread_prio (int tid, int val);

    /**@}*/

/**@}*/


/** \name Управление памятью */
/**@{*/

    /**
        Используется страничная организация памяти.
        Виртуализация памяти не используется, адресация прямая (v_adr == p_adr).

        Текущий процесс становится собственником участка памяти. Он может передавать права
        доступа другим процессам в разных режимах через интерфейс обмена сообщениями.
        Также выделенная память может быть использована для загрузки исполняемого образа и
        запуска другого процесса с помощью proc_create, после чего ее собственником становится новый процесс.
    */

    /** \defgroup mem Память
        \ingroup API */
    /**@{*/

    /** \brief Получение N страниц памяти с заданного адреса

        Номер вызова: \b SYSCALL_MMAP

        Вызов предназначен для захвата заданных адресов памяти.
        Ориентирован прежде всего для применения в драйверах устройств.

        \note Для отладки выделенная память может быть использована для загрузки исполняемого образа.

        \param address   Стартовый адрес получения страниц
        \param num       Число запрашиваемых страниц
        \param attr      Атрибуты памяти

        \return Ошибки выполнения
        \retval ERR_MEM_BUSY        Одна из страниц памяти занята
    */
    __syscall int os_mmap (size_t address, int num, struct mem_attributes attr);


    /** \brief Выделение заданного числа смежных страниц памяти.

        Номер вызова: \b SYSCALL_MALLOC

        Выделение заданного количества страниц памяти из динамической памяти.

        \param num   Число требуемых страниц
        \param attr  Атрибуты памяти
        \param align Выравнивание требуемых страниц, байт. Из входного параметра align
                     берется только младший бит начиная с удвоенного размера страницы
                     (степень двойки размера страницы), то есть:
                     align = (align + PAGE_SIZE - 1) & (-PAGE_SIZE);
                     align = = align & (-align);

        \return Указатель на первую выделенную страницу или Код ошибки
    */
    __syscall void* os_malloc (int num, struct mem_attributes attr, size_t align);


    /** \brief  Освобождение памяти

        Номер вызова: \b SYSCALL_MFREE

        Право выполнения имеет только процесс-владелец.
        Если выделенная память расшарена другим процессом, то она просто
        удаляется из карты памяти данного процесса.

        \param ptr   Указатель на выделенную память

        \return Ошибки выполнения
    */
    __syscall int os_mfree (void *ptr);

    /**@}*/

/**@}*/


/** \name Межпроцессное взаимодействие*/
/**@{*/

    /** \section ipc Обмен сообщениями

        Основной механизм межпроцессного обмена - обмен сообщениями.

        Обмен сообщениями осуществляется через связанные объекты: соединение -> канал.
        Для приема сообщений необходимо создать канал доставки сообщений.
        Для отправки сообщений необходимо установить соединение к требуемуму каналу.

        При создании соединения может задаваться номер приватного канала для доставки ответов,
        к нему автоматически устанавливается обратное соединение.
        [ответное соединение -> канал ответов]
        Это соединение закрывается автоматически при закрытии соединения.
        Но после этого всеравно требует явного закрытия.

        Каналы закрываются согласно их настройкам и условиям.

        \par
        Каналы бывают трех типов:
            CHANNEL_PUBLIC      Общедоступный канал.
                                Соединения к нему через системный вызов открытия соединения.
                                Соединения поддерживают процедуру ожидания/подтверждения со стороны канала.
                                Политика доступа к ним реализуется в МБ и владельцем канала.

            CHANNEL_PROTECTED   Защищенный канал.
                                Соединения к нему могут быть перенаправленных из родительского процесса.
                                Соединения поддерживают процедуру ожидания/подтверждения со стороны канала.
                                Политика доступа к ним реализуется только владельцем канала.
                                Перенаправления возможны только механизмом продвижения по "полному пути" через суффикс.

            CHANNEL_PRIVATE     Приватный канал.
                                Соединения к нему могут быть перенаправленны внутри процесса.
                                Соединения устанавливаются автоматически.

        Каналы и соединения доступны всем потокам процесса на получение и отправку сообщений.

        Проверки при установке соединения к запрашиваемомоу каналу в системе (МБ и обработка получателем)
        являются механизмом обеспечивающим защищенность обмена.

        \note Важаная парадигма разработки обмена.
        Всегда старайтесь добиться обмена приватный-приватный между процессами.
        Открывайте публичные или защищенные каналы только для редиректа.

        \note Используйте соединения и их удержание для захвата ресурсов.

        \warning Для межпоточного обмена используйте средства межпоточной синхронизации.
    */

    /** \defgroup ipc Межпроцессное взаимодействие
        \ingroup API
    */
    /**@{*/

    #define CHANNEL_AUTO_KILL           0x01
    #define CHANNEL_SINGLE_CONNECTION   0x02
    #define CHANNEL_AUTO_CONNECT        0x04

    /** \brief Создание и открытие канала для приема сообщений

        Номер вызова: \b SYSCALL_CHANNEL_OPEN

        Канал - это буфер FIFO для приема сообщений, доступный процессу только на чтение (RO).
        Для доставки сообщений к каналу требуется установить соединение.

        \param type       Тип канала
        \param pathname   Имя канала с путем в корневом пространстве имен
        \param size       Размер буфера канала для приема сообщений

        \param flags      CHANNEL_AUTO_KILL  - автозакрытие канала при закрытии к нему всех соединений
                                               (срабатывает только если к нему уже были соединения)
                                               все RECEIVE блокированные потоки разблокируются
                                               и возвращается код ошибки ERR_CLOSED
                                               Требует явного вызова os_channel_close !!!

                          CHANNEL_SINGLE_CONNECTION
                          CHANNEL_AUTO_CONNECT

        \return Идентификатор канала или Код ошибки
        \retval ERR_CHANNEL_NAME_USED
    */
    __syscall int os_channel_open (channel_type_t type, char *pathname, int size, int flags);

    /** \brief Ожидание соединения к каналу приема сообщений

        \param       chid      Идентификатор канала
        \param[out]  info      Описание устанавливаемого соединения
        \param       timeout   Время ожидания, нс

    */
    __syscall int os_channel_wait_connection (int chid, struct connection_info *info, uint64_t timeout);

    /** \brief Завершение этапа формирования соединения к каналу приема сообщений

        \param chid    Идентификатор канала
        \param cmd     Результат этапа
                         - OK       - разрешить (подключится к текущему каналу)
                         - REDIRECT - продолжить (дальнейшая обработка по connection_info->suffix)
                         - PRIVATE  - разрешить (подключится к локальному закрытому каналу)
                         - ERR      - отказать (ошибка)

        \return Ошибки выполнения
                Номер соединения для ответа
    */
    __syscall int os_channel_complete_connection (int chid, enum connection_cmd cmd, int result);

    /** \brief Закрытие канала приема сообщений

        Номер вызова: \b SYSCALL_CHANNEL_CLOSE

        Может выполнять только процесс, открывший соединение.

        \param id  Идентификатор канала

        \return Ошибки выполнения
    */
    __syscall int os_channel_close (int chid);

    #define NO_REPLY                0

    /** \brief Создание и открытие соединения к каналу приема сообщений

        Номер вызова: \b SYSCALL_CONNECTION_OPEN

        Для отправки сообщений в канал, требуется открыть соединение.

        Процесс открытия соединения:
            - по id
            - по пути

        \param chid        Идентификатор канала
        \param pathname    Имя канала с путем в корневом пространстве имен
        \param reply_chid  Номер канала для обратного соединения (CHANNEL_PRIVATE).
                           Механизм - двунаправленного обмена между процессами.

        \return Идентификатор соединения или Код ошибки
        \retval ERR_CONNECTION_NAME_USED
    */
    __syscall int os_connection_open (char *pathname, int reply_chid, uint64_t timeout);


    /** \brief Закрытие соединения к каналу приема сообщений

        Номер вызова: \b SYSCALL_CONNECTION_CLOSE

        Может выполнять только процесс, открывший соединение.

        \param id  Идентификатор соединения

        \return Ошибки выполнения
    */
    __syscall int os_connection_close (int conid);

    #define MSG_WAIT_COMPLETE           0x01

    /**
        \brief Посылка сообщения

        Номер вызова: \b SYSCALL_SEND

        Посылка сообщения через соединение.\n
        Осуществляется буферизированная доставка сообщения в канал (неблокирующий вызов).
        При переполнении буфера принимающего канала передающий поток автоматически блокируется
        до появления свободного места на время timeout.
        Если указывается не блокирующий тип доставки (timeout = NO_WAIT),
        то при переполнении буфера будет возвращен соответствующий код ошибки.
        Предусмотрено дополнительное управление блокировкой на отправление (см. флаги)

        \param conid    Номер соединения
        \param m        Указатель на сообщение
        \param timeout  время ожидания отправки, нс
                        или
                        NO_WAIT - не ждать, если приемник не может принять сообщение
                        TIMEOUT_INFINITY - бесконечное ожидание
        \param flags    TODO флаг передачи приоритета

        \return Ошибки выполнения
        \retval ERR_SEND_FULL   Переполнение очереди приема
    */
    __syscall int os_send (int conid, struct msg *m, uint64_t timeout, int flags);


    /** \brief Прием сообщения

        Номер вызова: \b SYSCALL_RECEIVE

        Получение сообщения из канала приема.\n
        Если очередь пуста, происходит блокировка потока.
        Ожидание сообщения можно ограничить таймаутом, по истечении
        которого вызывающий поток разблокируется и вызов возвращает ошибку.

        \warning Указатель на сообщение действителен после вызова, до следующего вызова

        \param       chid         Номер канала
        \param[out]  m            Сообщение
        \param       timeout      время ожидания получения, нс
                                  NO_WAIT - неблокирующий вызов
                                  TIMEOUT_INFINITY - бесконечная блокировка

        \return Номер соединения для ответа или Код ошибки
        \retval ERR_RECEIVE_TIMEOUT
    */
    __syscall int os_receive (int chid, struct msg **m, uint64_t timeout);

    /**@}*/

/**@}*/


/** \name Управление прерываниями */
/**@{*/

    /** \section irq Прерывания
        Обработчики прерываний - это потоки процессов.
        Обработчикам прерываний доступен более широкий диапазон приоритетов (вплоть до IRQ_PRIO)

        Поток каждый раз запускается на обработку сигнала прерывания и должен завершиться до возникновения следующего сигнала и за отведенный квант.
        Если квант исчерпан, а поток не завершен, приоритет снижается до приоритета процесса.
    */

    /** \defgroup irq Прерывания
        \ingroup API */
    /**@{*/

    /** \brief Захватить прерывание и установить обработчик

        Номер вызова: \b SYSCALL_IRQ_HOOK

        Поток с идентификатором tid помечается системой потоком обработчика прерывания заданного вектора.

        \param irq_id Номер вектора прерывания
        \param tid  Идентификатор потока

        \return Ошибки выполнения
    */
    __syscall int os_irq_hook (int irq_id, int tid);


    /** \brief Освободить прерывание

        Номер вызова: \b SYSCALL_IRQ_RELEASE

        \param irq_id Номер вектора прерывания

        \return Ошибки выполнения
    */
    __syscall int os_irq_release (int irq_id);


    /** \brief Управление прерыванием

        Номер вызова: \b SYSCALL_IRQ_CTRL

        Управление обработкой прерывания.

        \param irq_id Номер вектора прерывания
        \param ctrl Управляющая структура

        \return Ошибки выполнения
    */
    __syscall int os_irq_ctrl (int irq_id, struct irq_ctrl ctrl);

    /**@}*/

/**@}*/


/** \name Средства синхронизации */
/**@{*/

    /** Неименованные объекты синхронизации предназначены для использования в одном процессе локально.
        Именованные объекты синхронизации могут применяться для синхронизации процессов между собой.
        Они размещаются в корневом пространстве имен микроядра.
    */

    /** \defgroup sync Средства синхронизации
        \ingroup API */
    /**@{*/

    /** \brief Создание объекта синхронизации: мьютекса, семафора, барьера

        Номер вызова: \b SYSCALL_SYN_CREATE

        Процесс-создатель автоматически получает доступ к объекту для вызова рабочих функций
        syn_wait и syn_done. Его потоки не должны вызывать syn_open и syn_close.
        \param s       - тип и параметры объекта, его рабочие поля для локального мьютекса и локального семафора
        \return >0     - идентификатор объекта синхронизации
                ERR                 - ошибка пути или др.
                ERR_BUSY            - в пространстве имен уже существует объект с таким путем
                ERR_ACCESS_DENIED   - невозможно создать объект с заданным путем, возможны вложения
    */
    __syscall int os_syn_create (struct syn *s);


    /** \brief Удаление объекта синхронизации

        Номер вызова: \b SYSCALL_SYN_DELETE

        Только владелец-создатель может удалить объект синхронизации.

        В стандартном режиме (unlink = 0) удаление будет выполнено после завершения всех сеансов в других
        процессах по syn_close или до завершения этих процессов. Все блокированные на объекте потоки будут разбужены,
        и по системным вызовам syn_wait и syn_done будут всегда возвращаться ошибки до завершения удаления объекта.
        Системный вызов os_syn_delete завершается раньше завершения всех действий по удалению объекта из системы.

        В режиме удаления с отвязкой (unlink > 0) удаление будет отложено до завершения всех сеансов в других процессах
        по syn_close или до завершения этих процессов. При этом блокированные потоки не будут разбужены,
        работа с объектом может быть продолжена в других процессах с открытыми сеансами.

        При удалении именованного объекта соответствующий ресурс в корневом пространстве имен будет освобожден сразу
        и может быть занят другим объектом.

        \param id       Идентификатор открытого по os_syn_open или созданного по os_syn_create объекта синхронизации
        \param unlink   Стандартное удаление при unlink = 0, удаление с отвязкой при unlink > 0

        \return Ошибки выполнения
    */
    __syscall int os_syn_delete (int id, int unlink);


    /** \brief Открытие объекта синхронизации

        Номер вызова: \b SYSCALL_SYN_OPEN

        Начало работы с мьютексом,семафором или барьером.
        При этом вызове происходят проверки на разрешение работы с этим объектом.
        \note После открытия именованного объекта синхронизации - работа с ним идет только через идентификатор.

        \param name     Имя объекта синхронизации
        \param type     Тип объекта синхронизации
        \return >0                - идентификатор
                ERR_ILLEGAL_ARGS  - указан пустой путь
                ERR_ACCESS_DENIED - доступ не возможен, наличие объекта
    */
    __syscall int os_syn_open (const char *pathname, enum syn_type type);


    /** \brief Закрытие объекта синхронизации

        Номер вызова: \b SYSCALL_SYN_CLOSE

        Завершение работы с объектом синхронизации. Не удаляет объект из ядра

        \param id       Идентификатор открытого по os_syn_open или созданного по os_syn_create объекта синхронизации

        \return OK  - выполнено
                ERR - не верный идентификатор
    */
    __syscall int os_syn_close (int id);


    /** \brief Выполнение синхронизации потока с другими по указанному объекту (начало блока синхронизации)

        Номер вызова: \b SYSCALL_SYN_WAIT

        \param id  Идентификатор открытого по os_syn_open или созданного по os_syn_create объекта синхронизации
        \param timeout  время захвата, нс
                         TIMEOUT_INFINITY - бесконечно
                         NO_WAIT - попытка синхронизации без блокировки

        \return OK          - синхронизация выполнена (начало блока синхронизации)
                ERR_TIMEOUT - синхронизация не выполнена по истечении таймаута
                ERR_BUSY    - синхронизация не выполнена, условие синхронизации не выполнено
                ERR         - не верный идентификатор (не доступен для работы)
                ERR_DEAD    - объект помечен на удаление владельцем, необходимо закрыть сеанс работы с ним
                                по os_syn_close в процессах кроме владельца

    */
    __syscall int os_syn_wait (int id, uint64_t timeout);


    /** \brief Завершение блока синхронизации, только для мьютексов и семафоров

        Номер вызова: \b SYSCALL_SYN_DONE

        \param id  Идентификатор открытого по os_syn_open или созданного по os_syn_create объекта синхронизации

        \return OK          - блок синхронизации завершен
                ERR         - не верный идентификатор (не доступен для работы) или
                              мьютекс не был захвачен текущим потоком по syn_wait
                ERR_DEAD  - объект помечен на удаление владельцем, необходимо закрыть сеанс работы с ним
                                по os_syn_close в процессах кроме владельца
    */
    __syscall int os_syn_done (int id);

    /**@}*/

/**@}*/


/** \name Системные утилиты */
/**@{*/

    /** \defgroup utils Системные
        \ingroup API */
    /**@{*/

    /** \brief Завершение работы

        Номер вызова: \b SYSCALL_SHUTDOWN

        Завершение всех процессов и остановка процессоров или выключение питания.
        Далее должно следовать ручное выключение питания (после приглашения) или перезагрузка.

        \return Управление не возвращается
    */
    __syscall int os_shutdown ();


    /** \brief Запрос информации об ОС

        Номер вызова: \b SYSCALL_GET_INFO

        Вывод запрашиваемой информации по типу
        (версия ОС, запущенные процессы, использование памяти, использование процессора и т.д.)

        \param[in]  type  Тип запрашиваемой информации
        \param[out] info  Информация

        \return Ошибки выполнения
    */
    __syscall int os_get_info (int type, union os_info *info);


    /** \brief Запрос или установка времени

        Номер вызова: \b SYSCALL_TIME

        \param[in] clock_id  OS_CLOCK_MONOTONIC  - время работы от старта системы,
                                                не может изменяться процессами
                             OS_CLOCK_REALTIME   - реальное время, если установлено,
                                                 иначе равно CLOCK_MONOTONIC
        \param[in] newval указатель на значение времени для установки, только для
                           OS_CLOCK_REALTIME и процесса-драйвера часов реального времени,
                           который определяется по первому системному вызову установки времени
        \param[out] val указатель на возвращаемое значение времени

        \return Ошибки выполнения
    */
    __syscall int os_time (int clock_id, kernel_time_t *val, kernel_time_t *newval);


    /** \brief Конфигурация ОС

        Номер вызова: \b SYSCALL_CTRL

        \param ctrl  Управляющая структура

        \return Ошибки выполнения
    */
    __syscall int os_ctrl (struct os_ctrl *ctrl);

    /**@}*/

/**@}*/

#include <os_arm.h>

#ifdef __cplusplus
}
#endif
#endif
