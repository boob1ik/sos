#include <config.h>

    .section .init, "ax"
    .arch armv7-a
    .cpu cortex-a9
    .syntax unified
    .arm
    .align 4

    .set  Mode_USR, 0x10            // User Mode
    .set  Mode_FIQ, 0x11            // FIQ Mode
    .set  Mode_IRQ, 0x12            // IRQ Mode
    .set  Mode_SVC, 0x13            // Supervisor Mode
    .set  Mode_ABT, 0x17            // Abort Mode
    .set  Mode_UNDEF, 0x1B          // Undefined Mode
    .set  Mode_SYS, 0x1F            // System Mode

    .set  NO_IRQ, 0x80               // when IRQ is disabled
    .set  NO_FIQ, 0x40               // when FIQ is disabled
    .set  NO_INTS, 0xc0

    .set  VFP_ENABLED,                  0x40000000
    .set  CPU_CONTEXT_KERNEL_SWITCH,    0x2

    .globl irq_handler_s
    .globl interrupt_handler
    .globl cpu_context_switch_s
    .globl ret_thread_switch_s
    .globl zeroes


    // В обработчик прерываний можем попасть из режимов:
    // - User(выполнение потока пользователя или потока-обработчика прерываний
    // пользователя) или
    // - System (из кода ОС)
    // - Supervisor (из кода ОС)
    //
    // Состояние исходного режима и точку возврата сохраняем в системном стеке,
    //  который выделяется отдельно для каждого потока
    //  чтобы исключить возможность повреждения пользовательскими потоками состояние возврата
    //  и несанкционированный переход процесса из User в привилегированный режим,
    //  а также для хранения контекста выполнения кода ядра, который относится к потоку
    // Другие регистры также сохраняем в стеке SVC, т.к. значению SP SVC можно доверять
    // Считаем, что микроядро не использует регистры сопроцессоров, поэтому их состояние не
    //  нужно сохранять пока не будет переключения на другой поток, отличный от исходного
    // Предварительная обработка выполняется микроядром вначале в режиме Supervisor,
    // затем микроядро либо выполняет код обработчика прерывания ядра
    // (системного таймера времени или диспетчера задач) в Supervisor,
    // либо, если имеется зарегистрированный активный поток обработчика прерывания,
    // запускает его как новый поток и переключает контекст на новый поток.

irq_handler_s:
    sub     lr, lr, #4
    srsfd   sp!, #Mode_SVC  // USR/SVC ret lr,spsr -> SVC stack for security return
    cpsid   i, #Mode_SVC    // вытеснение должно быть выключено, предыдущее состояние режима SVC могло быть другим
    stmfd   sp!, {r11, r12, lr} // сохраняем сразу для возможности использования -> SVC stack
                            // lr -> SVC stack, lr_SVC - для поддержки вложенных прерываний кода в SVC
    cpsid   i, #Mode_SYS
    mov     r11, sp         // USR/SYS sp     -> r11 -> SVC stack
    mov     r12, lr         // USR/SYS lr     -> r12 -> SVC stack
    cps     #Mode_SVC
    stmfd   sp!, {r0-r12}   // regs -> SVC stack

    ldr     r0,=zeroes
    ldmia   r0, {r2-r12}

#ifdef  SUPPORT_VFP
    sub     sp, #(256)
    stmfd   sp!, {r2, r3}   // В контексте пока пишем значения по умолчанию FPEXC = 0 и FPSCR = 0,
                            // так как не каждый восстанавливаемый контекст должен включать восстановление регистров VFP
                            // (по флагу в сохраненном FPEXC определяем, нужно ли восстанавливать регистры,
                            // необходимо исключить восстановление регистров больше одного раза перед возвратом в поток)
                            // это определяется тем какой контекст у потока был в момент его вытеснения,
                            // мы применяем метод отложенного сохранения регистров VFP по необходимости,
                            // только перед непосредственным переключением на другой поток
#endif

    stmfd   sp!, {r0}       // первым идет поле типа контекста, оно будет заполнено позже
    mov     r0, sp          // возвращаем адрес контекста процессора struct cpu_context *ptr

    // стек SVC должен быть выровнен на 8 байт для кода на C - ARM AAPCS
    mov     r1, sp
    and     r1, r1, #4
    orr     r1, r1, #4
    sub     sp, sp, r1
    stmfd   sp!, {r1}       // SVC sp adjustement, dummy

    ldr     r1,=interrupt_handler
    blx     r1

    // если сюда вернулись(обычно не возвращаемся так как вызывается диспетчер), то
    // обратное выравнивание не нужно, так как sp грузится принудительно правильным значением
    // ниже
cpu_context_switch_s:
    // Код ниже работает в двух случаях:
    // 1) после выполнения функции ядра в обработчике без смены контекста на другой поток,
    //      простой выход из обработчика с обратной раскруткой системного стека текущего потока
    // 2) выполняется переключение контекста на другой поток с потерей стековой истории текущего сеанса SVC ядра ОС
    // input r0 - адрес контекста, сохраненный выше при входе в прерывание или в системный вызов svc
    // Регистры VFP уже должны быть восстановлены если нужно, здесь их пропускаем

    clrex   // очистка состояния монитора эксклюзивного доступа,
    //      необходимо делать на каждом выходе из исключения

    mov     sp, r0
    ldmfd   sp!, {r0}       // тип контекста
    cmp     r0, #CPU_CONTEXT_KERNEL_SWITCH
    beq     ret_thread_switch_s

#ifdef SUPPORT_VFP
    add     sp, #(256 + 8)
#endif

    ldmfd   sp!, {r0-r12}
//    msr     SP_usr, r0 // такие команды не поддерживаются в ARMv7-A, а было бы удобно
    cpsid   i, #Mode_SYS
    mov     sp, r11          // SVC stack -> USR/SYS SP
    mov     lr, r12          // SVC stack -> USR/SYS LR
    // TODO разрешать или нет прерывания в SVC?
    // если работали в длительном системном вызове и прервались, то rfe восстановит
    // корректно прерванный режим и разрешение прерываний, а если...
    // ведь код  этот может выполняться и при вызове переключения не по прерыванию,
    // а по другим событиям (блокировки и т.п.) при выполнении системного вызова
    cps     #Mode_SVC
    ldmfd   sp!, {r11, r12, lr}
    rfefd   sp!             // Возвращаемся в USR или SVC (если поток прерывался в
                            // точке системного вызова

    .align 4
zeroes:     .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0



