#include <os.h>
#include <syn\spinlock.h>
#include <syn\_spinlock.h>
#include <syn\atomics.h>
#include <syn\_atomics.h>

// Основной принцип работы быстрых мьютексов - захват и освобождение без системных вызовов
// при отсутствии конкурентов на захват, иначе выполнение функций обычных мьютексов с
// организацией очередей ожидания захвата через системные вызовы. Реализация таких метов
// требует тесного взаимодействия кода режима пользователя и системных вызовов ядра.
// При этом необходимо обеспечить целостность транзакций захвата и освобождения мьютекса в
// разных режимах, отказоустойчивость и надежность на случай непредвиденного поведения
// процесса при работе с мьютесом (например при "развале" процесса).
// Быстрые мьютексы, локальные для процесса, являются самым оптимальным средством синхронизации
// потоков внутри процесса

int plocal_mutex_wait (syn_t *m, uint64_t timeout) {
    int res;
    int *tls_tid_value;
    // выполняем транзакцию захвата мьютекса, если он полностью свободен(нет ожидающих потоков),
    // то есть когда cnt = 0
    if (atomic_dec_if_one(&m->cnt) == 0) {
        // если успешно захватили, установим владельца - себя для выполнения
        // функций мьютекса путем самоконтроля, если никто кроме текущего потока
        // в данном блоке синхронизации не будет претендовать на захват
        asm volatile ("str r9, [%0]":: "r" (&tls_tid_value): "cc");
        m->owner_tid = *tls_tid_value;
        res = OK;
    } else {
        // уже есть захватчик, поток должен встать в очередь на захват через системный вызов и
        // заснет до передачи управления с захватом мьютекса или истечения таймаута
        res = os_syn_wait(m->id, timeout);
    }
    return res;
}

int plocal_mutex_done (syn_t *m) {
    int res;
    int *tls_tid_value;
    asm volatile ("str r9, [%0]":: "r" (&tls_tid_value): "cc");
    // выполняем самоконтроль перед попыткой быстрого освобождения без системного вызова
    if(m->owner_tid != *tls_tid_value) {
        res = ERR_ACCESS_DENIED;
    } else if (atomic_inc_if_zero(&m->cnt) == 0) {
        // выполнена быстрая транзакция освобождения мьютекса в отсутствии ожидающих в очереди
        res = OK;
    } else {
        // очередь заблокированных на мьютексе потоков не пустая, необходимо разблокировать
        // следующий поток в очереди
        res = os_syn_done(m->id);
    }
    return res;
}
